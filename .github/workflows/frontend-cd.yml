# week08/.github/workflows/frontend-cd.yml

name: CD - Deploy Frontend to AKS

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy (default: latest)"
        required: false
        default: "latest"

env:
  NAMESPACE: ""   # leave empty to use default namespace

jobs:
  deploy_frontend:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Derive env (ACR, TAG, node RG)
        shell: bash
        run: |
          echo "ACR_LOGIN_SERVER=${{ secrets.ACR_LOGIN_SERVER }}" >> $GITHUB_ENV
          echo "TAG=${{ github.event.inputs.image_tag || 'latest' }}" >> $GITHUB_ENV
          NODE_RG=$(az aks show -n "${{ secrets.AKS_CLUSTER }}" -g "${{ secrets.AKS_RG }}" --query nodeResourceGroup -o tsv)
          echo "NODE_RG=$NODE_RG" >> $GITHUB_ENV
          echo "Node RG: $NODE_RG"

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ secrets.AKS_RG }}
          cluster-name:   ${{ secrets.AKS_CLUSTER }}

      # If ACR was never attached to the cluster, attach it (no-op otherwise).
      - name: Attach ACR to AKS (best effort)
        shell: bash
        run: |
          ACR_NAME=$(echo "${ACR_LOGIN_SERVER}" | cut -d. -f1)
          az aks update -n "${{ secrets.AKS_CLUSTER }}" -g "${{ secrets.AKS_RG }}" --attach-acr "$ACR_NAME" || true

      - name: Ensure namespace (optional)
        if: env.NAMESPACE != ''
        run: |
          kubectl get ns "$NAMESPACE" || kubectl create ns "$NAMESPACE"

      - name: Ensure frontend Deployment & Service
        shell: bash
        run: |
          if [ -f k8s/frontend.yaml ]; then
            kubectl ${NAMESPACE:+-n $NAMESPACE} apply -f k8s/frontend.yaml
          elif [ -d k8s/frontend ]; then
            kubectl ${NAMESPACE:+-n $NAMESPACE} apply -f k8s/frontend/
          else
            cat <<'YAML' | kubectl ${NAMESPACE:+-n $NAMESPACE} apply -f -
            apiVersion: apps/v1
            kind: Deployment
            metadata: { name: frontend, labels: { app: frontend } }
            spec:
              replicas: 1
              selector: { matchLabels: { app: frontend } }
              template:
                metadata: { labels: { app: frontend } }
                spec:
                  containers:
                    - name: frontend
                      image: nginx:alpine
                      ports: [ { containerPort: 80 } ]
                      readinessProbe: { httpGet: { path: /, port: 80 }, initialDelaySeconds: 5, periodSeconds: 10 }
                      livenessProbe:  { httpGet: { path: /, port: 80 }, initialDelaySeconds: 10, periodSeconds: 20 }
            ---
            apiVersion: v1
            kind: Service
            metadata: { name: frontend, labels: { app: frontend } }
            spec:
              type: LoadBalancer
              selector: { app: frontend }
              ports: [ { port: 80, targetPort: 80 } ]
            YAML
          fi

      # Free public IP quota by making backends internal (no error if already ClusterIP)
      - name: Make backend services ClusterIP (free PIPs) â€“ best effort
        shell: bash
        run: |
          kubectl patch svc product-service -p '{"spec":{"type":"ClusterIP"}}' || true
          kubectl patch svc order-service   -p '{"spec":{"type":"ClusterIP"}}' || true

      # Make sure AKS knows the node RG where PIPs live
      - name: Annotate frontend Service with node RG
        shell: bash
        run: |
          kubectl annotate svc frontend service.beta.kubernetes.io/azure-load-balancer-resource-group="$NODE_RG" --overwrite || true

      - name: Set image to ACR tag and rollout
        shell: bash
        run: |
          IMG="${ACR_LOGIN_SERVER}/frontend:${TAG}"
          kubectl ${NAMESPACE:+-n $NAMESPACE} set image deploy/frontend frontend="$IMG" --record || true
          kubectl ${NAMESPACE:+-n $NAMESPACE} rollout status deploy/frontend --timeout=240s || true

      - name: Wait for frontend EXTERNAL-IP (soft wait, no fail)
        shell: bash
        run: |
          echo "Waiting up to 5 minutes for an external IP..."
          for i in {1..60}; do
            IP=$(kubectl ${NAMESPACE:+-n $NAMESPACE} get svc frontend -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
            if [ -n "$IP" ]; then
              echo "EXTERNAL-IP=$IP"
              echo "FRONTEND_IP=$IP" >> $GITHUB_ENV
              break
            fi
            sleep 5
          done
          kubectl ${NAMESPACE:+-n $NAMESPACE} get svc frontend -o wide || true

      - name: Describe frontend Service (diagnostics)
        if: env.FRONTEND_IP == ''
        run: kubectl ${NAMESPACE:+-n $NAMESPACE} describe svc frontend || true

      - name: Show services (final)
        run: kubectl ${NAMESPACE:+-n $NAMESPACE} get svc -o wide
