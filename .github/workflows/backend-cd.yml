name: CD - Deploy Backend Services to AKS

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy (default: latest)"
        required: false
        default: "latest"

env:
  # leave empty to use the default namespace
  NAMESPACE: ""

jobs:
  deploy_backend:
    runs-on: ubuntu-latest
    environment: Production

    outputs:
      PRODUCT_API_IP: ${{ steps.capture_ips.outputs.product_ip }}
      ORDER_API_IP:   ${{ steps.capture_ips.outputs.order_ip }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Derive ACR + tag
        run: |
          echo "ACR_LOGIN_SERVER=${{ secrets.ACR_LOGIN_SERVER }}" >> $GITHUB_ENV
          echo "ACR_NAME=$(echo '${{ secrets.ACR_LOGIN_SERVER }}' | cut -d. -f1)" >> $GITHUB_ENV
          echo "TAG=${{ github.event.inputs.image_tag || 'latest' }}" >> $GITHUB_ENV

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ secrets.AKS_RG }}
          cluster-name:   ${{ secrets.AKS_CLUSTER }}

      # harmless if already attached; won't fail the job
      - name: Attach ACR permissions (best effort)
        run: |
          az aks update -n "${{ secrets.AKS_CLUSTER }}" -g "${{ secrets.AKS_RG }}" --attach-acr "$ACR_NAME" || true

      - name: Ensure namespace (optional)
        if: env.NAMESPACE != ''
        run: |
          kubectl get ns "$NAMESPACE" || kubectl create ns "$NAMESPACE"

      # --- Ensure Postgres backends exist (creates or updates) ---
      - name: Ensure product-db
        run: |
          kubectl ${NAMESPACE:+-n $NAMESPACE} apply -f - <<'YAML'
          apiVersion: apps/v1
          kind: Deployment
          metadata: { name: product-db }
          spec:
            replicas: 1
            selector: { matchLabels: { app: product-db } }
            template:
              metadata: { labels: { app: product-db } }
              spec:
                containers:
                  - name: postgres
                    image: postgres:15
                    env:
                      - { name: POSTGRES_PASSWORD, value: "postgres" }
                      - { name: POSTGRES_DB,       value: "products" }
                    ports: [ { containerPort: 5432 } ]
          ---
          apiVersion: v1
          kind: Service
          metadata: { name: product-db }
          spec:
            selector: { app: product-db }
            ports: [ { port: 5432, targetPort: 5432 } ]
          YAML

      - name: Ensure order-db
        run: |
          kubectl ${NAMESPACE:+-n $NAMESPACE} apply -f - <<'YAML'
          apiVersion: apps/v1
          kind: Deployment
          metadata: { name: order-db }
          spec:
            replicas: 1
            selector: { matchLabels: { app: order-db } }
            template:
              metadata: { labels: { app: order-db } }
              spec:
                containers:
                  - name: postgres
                    image: postgres:15
                    env:
                      - { name: POSTGRES_PASSWORD, value: "postgres" }
                      - { name: POSTGRES_DB,       value: "orders" }
                    ports: [ { containerPort: 5432 } ]
          ---
          apiVersion: v1
          kind: Service
          metadata: { name: order-db }
          spec:
            selector: { app: order-db }
            ports: [ { port: 5432, targetPort: 5432 } ]
          YAML

      # --- Ensure product-service + order-service exist (creates or updates) ---
      - name: Ensure product-service deployment & service
        run: |
          kubectl ${NAMESPACE:+-n $NAMESPACE} apply -f - <<'YAML'
          apiVersion: apps/v1
          kind: Deployment
          metadata: { name: product-service }
          spec:
            replicas: 1
            selector: { matchLabels: { app: product-service } }
            template:
              metadata: { labels: { app: product-service } }
              spec:
                containers:
                  - name: product-service
                    image: replace-later
                    imagePullPolicy: Always
                    env:
                      - { name: POSTGRES_HOST, value: "product-db" }
                      - { name: POSTGRES_PORT, value: "5432" }
                      - { name: POSTGRES_DB,   value: "products" }
                      - { name: POSTGRES_USER, value: "postgres" }
                      - { name: POSTGRES_PASSWORD, value: "postgres" }
                    ports: [ { containerPort: 3000 } ]
                    readinessProbe: { httpGet: { path: /health, port: 3000 }, initialDelaySeconds: 5, periodSeconds: 10 }
                    livenessProbe:  { httpGet: { path: /health, port: 3000 }, initialDelaySeconds: 10, periodSeconds: 20 }
          ---
          apiVersion: v1
          kind: Service
          metadata: { name: product-service }
          spec:
            type: LoadBalancer
            selector: { app: product-service }
            ports: [ { port: 80, targetPort: 3000 } ]
          YAML

      - name: Ensure order-service deployment & service
        run: |
          kubectl ${NAMESPACE:+-n $NAMESPACE} apply -f - <<'YAML'
          apiVersion: apps/v1
          kind: Deployment
          metadata: { name: order-service }
          spec:
            replicas: 1
            selector: { matchLabels: { app: order-service } }
            template:
              metadata: { labels: { app: order-service } }
              spec:
                containers:
                  - name: order-service
                    image: replace-later
                    imagePullPolicy: Always
                    env:
                      - { name: POSTGRES_HOST, value: "order-db" }
                      - { name: POSTGRES_PORT, value: "5432" }
                      - { name: POSTGRES_DB,   value: "orders" }
                      - { name: POSTGRES_USER, value: "postgres" }
                      - { name: POSTGRES_PASSWORD, value: "postgres" }
                    ports: [ { containerPort: 3001 } ]
                    readinessProbe: { httpGet: { path: /health, port: 3001 }, initialDelaySeconds: 5, periodSeconds: 10 }
                    livenessProbe:  { httpGet: { path: /health, port: 3001 }, initialDelaySeconds: 10, periodSeconds: 20 }
          ---
          apiVersion: v1
          kind: Service
          metadata: { name: order-service }
          spec:
            type: LoadBalancer
            selector: { app: order-service }
            ports: [ { port: 80, targetPort: 3001 } ]
          YAML

      - name: Set images to ACR tag and rollout
        run: |
          ns_flag=""
          [ -n "$NAMESPACE" ] && ns_flag="-n $NAMESPACE"
          PRODUCT_IMG="${ACR_LOGIN_SERVER}/product_service:${TAG}"
          ORDER_IMG="${ACR_LOGIN_SERVER}/order_service:${TAG}"

          kubectl $ns_flag set image deploy/product-service product-service="$PRODUCT_IMG" --record || true
          kubectl $ns_flag set image deploy/order-service   order-service="$ORDER_IMG"   --record || true

          kubectl $ns_flag rollout status deploy/product-service --timeout=240s || true
          kubectl $ns_flag rollout status deploy/order-service   --timeout=240s || true

      - name: Wait for LoadBalancer IPs (up to 6 minutes)
        id: capture_ips
        run: |
          ns_flag=""
          [ -n "$NAMESPACE" ] && ns_flag="-n $NAMESPACE"

          PRODUCT_IP=""
          ORDER_IP=""
          for i in $(seq 1 72); do
            echo "Attempt $i/72 to get external IPs ..."
            PRODUCT_IP=$(kubectl $ns_flag get svc product-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
            ORDER_IP=$(kubectl $ns_flag get svc order-service   -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
            if [ -n "$PRODUCT_IP" ] && [ -n "$ORDER_IP" ]; then
              echo "Product Service IP: $PRODUCT_IP"
              echo "Order Service IP:   $ORDER_IP"
              break
            fi
            sleep 5
          done

          if [ -z "$PRODUCT_IP" ] || [ -z "$ORDER_IP" ]; then
            echo "::error::One or more LoadBalancer IPs not assigned after timeout."
            exit 1
          fi

          echo "product_ip=$PRODUCT_IP" >> $GITHUB_OUTPUT
          echo "order_ip=$ORDER_IP"     >> $GITHUB_OUTPUT
          echo "PRODUCT_IP=$PRODUCT_IP" >> $GITHUB_ENV
          echo "ORDER_IP=$ORDER_IP"     >> $GITHUB_ENV

      - name: Show services
        run: kubectl ${NAMESPACE:+-n $NAMESPACE} get svc -o wide
